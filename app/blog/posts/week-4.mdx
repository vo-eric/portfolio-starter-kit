---
title: 'Perfect Code Whatever'
publishedAt: '2025-06-28'
summary: 'Just write something out'
---

I have a very annoying coding habit where I try to write my code in the most optimal way possible. The way I see it,
if the code is optimized from the beginning then I won't have to optimize it later on. This goes against my usual
attitude of "this is a future Eric problem." I like to think of this side of me as the good angel on my other shoulder -
the professional counterweight to the ever growing stack of future Eric problems. While admirable on paper, this habit of
mine has gotten in the way of me actually doing the task at hand. What can you optimize when there is nothing to optimize?

A few years ago when I was looking for my first "real" job in Software Engineering I found myself caught in the LeetCode
grind and I got into my head that when DSA questions come up in SWE interiews I want to provide a solution that is best
optimized for time and space. This idea led me to spending hours actively ignoring the brute force and easy solution because it
wasn't an effective use of time and it wouldn't get me anywhere. With the few technical interviews I had I found myself trying
to provide the most optimal solution and that it wholly blinded me from even providing a solution.

Unsurprisingly, having a suboptimal solution is infinitely better than having no solution and I started to pivot my thinking into writing
out an answer and then actively reasoning out how I could make it better. Having an answer in front of me allows me to reason out
why it's not optimal and allows me to funnel my thoughts into how I can make it better.

This week I was doing some Advent of Code challenges and caught myself in a problem that, at first glance, would have a O((n*m)^2) solution.
Immediately, the "how can I make this more optimal" side of my brain went into overdrive trying to reason out how to go about it. I ended up
spending 90 minutes testing out any random thought that came to mind that would be better and nothing came out of it. Eventually I went
with the O((n*m)^2) solution and got the answer within 20 minutes. Is it the most optimal solution? No, but at least I now have something to
work with when trying to reason it out.
